## 1. Shell 简介

### 1.1. Shell 环境

1. 运维工作必备技能

2. 种类众多，这里主要采用 `Bash`，也就是 `Bourne Again Shell`

### 1.2. 第一个shell脚本

> hello_world.sh

```bash
#!/bin/bash

# 输出
echo "Hello, bash world!"
```
- `#!/bin/bash`：告诉系统其后路径所指定的程序 `/bin/bash`, 即是解释此脚本文件的 Shell 程序
- 文件扩展名为 `sh`（代表 `shell`）
    - 这里的扩展名并不影响脚本执行，见名知意就好
    - 例如：若用 `php` 编写 Shell脚本，那么用 `php` 就好。


## 2. Shell 基础

### 2.1. Shell 执行方式

1、作为可执行程序
```sh
# 使脚本具有执行权限
chmod +x ./hello_world.sh
# 执行脚本
./hello_world.sh
```

2、作为解释器参数

```sh
/bin/sh test.sh
```


### 2.2. Shell 注释

```bash
#!/bin/bash

# 这里是单行注释

:<<a
这里是多行注释：第一行
这里是多行注释：第二行
这里是多行注释：第三行
a
```


### 2.3. 开发规范

1. 脚本命名
2. 首行必须写脚本解释器
3. 编写脚本基本信息
    - 文件中尽量使用英文注释，防止本机或切换系统环境后中文乱码
    - 常见的注释信息：名称，功能描述，版本，作者，日期

4. 优秀书写习惯
    1. 成对编写
    2. 空格留白

5. 编写脚本时，务必记住：脚本执行从上到下，依次执行。

## 3. 变量

### 3.1. 变量的分类

变量主要分为三类：

1. 本地变量
    - 普通变量
    - 命令变量
2. 全局变量

3. Shell 内置变量

### 3.2. 变量的定义

#### 3.2.1. 普通变量

1， 显式赋值
```bash
#!/bin/bash

# 方式一：
# 变量值必须是一个整体，中间没有特殊字符
my_str1=/user

# 方式二：
my_str2='/user'
# 可以输出空格等特殊字符，但是，若变量值有可解析变量，那么会原值输出
my_str2='dan $my_str1'

# 方式三：
my_str3="/user"
# 可输出空格等特殊字符，同时，如果变量值范围内有可解析变量，那么解析后再输出
my_str3="shuang $my_str1"

```
- 变量名和等号之间不能有空格
- 变量名的命名须遵循如下规则：
    - 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头
    - 中间不能有空格，可以使用下划线 `_`
    - 不能使用标点符号
    - 不能使用bash里的关键字（可用help命令查看保留关键字）

2， 语句赋值

```bash
#!/bin/bash

# 将 /etc 目录下的文件名循环导出
for list in $(ls /etc)
```
#### 3.2.2. 命令变量

显式赋值
```bash
#!/bin/bash

# 方式一：
# 采用反引号引用 Linux 系统命令
dir=`pwd`

# 方式二：
# 利用 $ + 小括号
dir=$(pwd)
```
- 命令变量的执行流程为：先执行系统命令，再赋值。

#### 3.2.3. 全局变量

查看全局变量值
```bash
# 查看当前系统所有全局变量命令
env

# 精确查看某全局变量
env | grep SHELL

# 当然，也可以直接查看变量值
$SHELL
```

定义全局变量
```bash
#!/bin/bash

# 方式一：先赋值变量，再使用 export 定义全局变量
aar='/home/aaron'
export aar

# 方式二：export 变量=值
export aar='/home/aaron'

```

### 3.3. 变量的使用

使用一个定义过的变量，只要 **在变量名前面加美元符号** 即可
- 填加 **花括号 ** 可以帮助解释器识别变量的边界

#### 3.3.1. 查看变量

```bash
#!/bin/bash

# 方式一：
$var_name

# 方式二：
"$var_name"

# 方式三：使用频率较高
${var_name}

# 常见使用场景
echo "Here is a commond using other var ${var_name}"

# 方式四：标准使用方式
"${var_name}"

```

### 3.4. 取消变量

```bash
#!/bin/bash

# 取消变量
uset var_name
```

### 3.5. Shell 内置变量

#### 3.5.1. 脚本相关

| 变量 |                                              说明                                               |
| --- | ----------------------------------------------------------------------------------------------- |
| S0  | 获取当前执行的she11脚本文件名，包括脚本路径                                                         |
| snr | 获取当前执行的she11脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名，如果n大于9就要用大括号括起来{10} |
| S#  | 获取当前she11命令行中参数的总个数                                                                  |
| s？ | 获取执行上一个指令的返回值（0为成功，非0为失败）                                                     |

验证

```bash
#!/bin/bash

# 验证与查看：获取脚本文件名命令：$0
echo "我的脚本名称：$0"

# 验证与查看：获取命令行参数命令 $n

echo "命令行第一个参数为：$1"
echo "命令行第二个参数为：$2"
echo "命令行第三个参数为：$3"
echo "命令行第零个参数为：$0"

# 验证与查看：获取当前脚本传入参数的数量命令：$#
echo "当前脚本传入参数数量为：$#"

# 验证与查看：获取执行上一个指令的返回值命令：$?
echo "上一条指令是否执行成功：$?"
```
- `$?`：仅仅查看执行上一个指令的状态：成功 or 失败。

## 4. Shell 进阶

### 4.1. 测试语句

测试语句格式：
1. `test 条件表达式`
2. ` [ 条件表达式 ]`
    - 这里的条件表达式前后都需要 **空格** 隔开

测试语句状态：
- 条件成立，返回状态值：0
- 不成立，返回状态值：1

### 4.2. 条件表达式

#### 4.2.1. 逻辑表达式

1， 逻辑表达式  `&&`

`命令1 && 命令2`
- 命令1执行成功，才执行命令2
- 执行不成功，命令2也不执行。



2，逻辑表达式 `||`

`命令|| 命令2`
- 命令1执行成功，命令2不再执行
- 命令1执行不成功，命令2再执行

#### 4.2.2. 文件表达式

| 命令 |           说明           |
| ---- | ----------------------- |
| `-f` | 判断输入内容是否是一个文件 |
| `-d` | 判断输入内容是否是一个目录 |
| `-x` | 判断输入内容是否可执行     |


#### 4.2.3. 数值操作符

比较两个数之间的关系

|    表达式    |  关系  |
| ----------- | ----- |
| `n1 -eq n2` | 等于   |
| `n1 -gt n2` | 大于   |
| `n1 -lt n2` | 小于   |
| `n1 -ne n2` | 不等于 |


#### 4.2.4. 字符串比较

|      表达式      |          关系          |
| --------------- | ---------------------- |
| `str1 == str2 ` | str1 与 str2 内容一致   |
| `str1 != str2 ` | str1 与 str2 内容不一致 |

#### 4.2.5. 计算表达式

| 格式  |      表达式      |                  说明                  |
| ---- | --------------- | ------------------------------------- |
| 格式1 | `$((计算表达式))` | 只能用 `+` `-` `*` `/` 和 `()` 等操作符 |
| 格式2 | `let 计算表达式`  | 无                                    |


### 4.3. 脚本常见 Linux 符号

#### 4.3.1. 重定向符号：`>` & `>>`

| 符号 |                             说明                             |
| ---- | ------------------------------------------------------------ |
| `>`  | 将符号 **左测** 内容，以 **覆盖** 方式输入到 **右侧** 文件中     |
| `>>` | 将符号 **左测** 内容，以 **追加** 方式输入到 **右侧** 文件末尾中 |

#### 4.3.2. 管道符 `|`

|      符号       |                           说明                           |
| -------------- | ------------------------------------------------------- |
| `命令1 | 命令2` | 将符号 **左测** 命令1执行结果，传递给管道符 **右侧** 命令2中 |

#### 4.3.3. 后台展示符号 `&`

|   符号   |           说明            |
| -------- | ------------------------- |
| `命令 &` | 将一个命令从前台转到后台执行 |

```bash
# 终端前台休眠 10s
sleep 10

# 转入后台执行
sleep 10 &
# 查看后台进程
ps aux | grep sleep
```

#### 4.3.4. 全部信息符号 `2>&1`

符号说明：
- `1`：表示正确输出的信息
- `2`：表示错误输出的信息
- `2>&1`：代表所有输出的信息

测试说明：
1. 添加文件 `all_info.sh`
```bash
#!/bin/bash

# 测试：全部信息符号 2>&1

echo "这一条是正确命令"
echo "下一条是错误命令"
sdflakj
```

2. 执行测试命令

```shell
# 命令1
$ bash all_info.sh 1>> right_info 2>> err_info

# 命令2
$ bash all_info.sh >> all_info 2>&1

```

Linux 系统垃圾桶 `/dev/null`
- `/dev/null` 是Linux 下的一个设备文件
- 该文件类似一个垃圾桶，容量无限大，也无需删除
- 因此，可以利用此特点执行测试命令

```shell
# 常用命令
$ bash bash_files.sh >> /dev/null 2>&1
```

### 4.4. 脚本常见 Linux 命令

#### 4.4.1. 文本搜索命令 `grep`




#### 4.4.2. `sed`



#### 4.4.3. `awk`


#### 4.4.4. 搜索命令 `find`













***
只读变量


删除变量

变量类型

Shell 字符串

单引号

双引号


拼接字符串


获取字符串长度

提取子字符串

查找在字符串

Shell 数组







***

第一阶段；Shell 编程
1.1 快速入门
	- 运维（了解）
	- Shell 简介
1.2 Shell 基础
	- Shell 脚本
	- 三种变量
1.3 Shell 进阶
	- 测试语言
	- 表达
	- Linux 常见符号
	- Linux 常见命令

1.4 Shell 流程控制语包
	- 简单流程控制
	- 复杂流程控制

第二阶段线码发布
2.1代码部署：部署定义、方式、流程
2.3手工方式部署代码
2.4脚本方式部署代码


